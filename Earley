
#testing OOP usage:

class word:

    befdot: list
    aftdot: list

    def __init__(self, word: str) -> any:
        self.befdot = []
        self.aftdot = [x for x in word]
        for x in self.aftdot:
            if not (x.islower()):
                print("palavra invalida")
                return []
    
    def advance(self) -> bool:
        if len(self.aftdot):
            self.befdot.append(self.aftdot.pop(0))
            return True
        return False


class production:

    num: int
    start: str
    befdot: list
    aftdot: list

    def __init__(self, num: int, start: str, befdot: list, aftdot: list) -> any:
        self.num = num
        self.start = start
        self.befdot = befdot
        self.aftdot = aftdot

    def advance(self) -> any:
        if self.aftdot:
            self.aftdot = list(self.aftdot)
            self.befdot.append(self.aftdot.pop(0))
        else:
            return False
        return self

    def copy(self, num) -> any:
        p = production(num, self.start, self.befdot, self.aftdot)
        return p
    
    def compare(self, prod: any) -> bool:
        if prod.num == self.num and prod.start == self.start and prod.aftdot == self.aftdot and prod.befdot == self.befdot:
            return True
        return False

class step:

    num: int
    prods: list
    word: word

    def __init__(self, num: int, word: word) -> None:
        self.prods = []
        self.num = num
        self.word = word

    def addProd(self, prod: production) -> bool:
        for pro in self.prods:
            if pro.compare(pro)  :
                return False
        self.prods.append(prod)
        return True

    def showProds(self) -> None:
        for p in self.prods:
            print(p.start, "->", str(p.befdot if (len(p.befdot)) else '' ) + '.' + str(p.aftdot) + '/' + str(p.num))        
        


class grammar:

    Vars: list
    Term: list
    Prod: dict
    Star: str
    step0: step

    def __init__(self) -> None:
        self.Vars = []
        self.Term = []
        self.Prod = {}
        self.Star = ""
        self.step0 = step(0, "")

    
    def addRule(self, V: str, O: str) -> None:
        if V in self.Vars:
            self.Prod[V] += O.split('|')
        else:
            self.Prod.update({V: O.split('|')})
            self.Vars.append(V)

        for x in O:
            if (x == '|'):
                pass
            elif (x.islower() or x == '£') and x not in self.Term :
                self.Term.append(x)
            elif(x.isupper() and (x not in self.Vars)) :
                self.Vars.append(x)
                self.Prod.update({x: []})

    def init(self) -> bool:
        for p in self.Prod['S']:
            pro = production(0, "S", [], p)
            self.step0.addProd(pro)
        for p in self.step0.prods:
            if p.aftdot[0].isupper() :
                for p1 in self.Prod[p.aftdot[0]]:
                    pro = production(0, p.aftdot[0], [], p1)
                    self.step0.addProd(pro)
        if len(self.step0.prods):
            self.step0.showProds()
            return True
        return False
            
    def validate(self, word: word) -> bool:
        steps = [self.step0]
        actstep = 0
        actword = word

        while actword.advance():
            actstep += 1
            stepr = step(actstep, actword)
            # productions that can build the next symbol
            for x in steps[actstep-1].prods :
                if x.aftdot[0] == actword.aftdot[0] :
                    stepr.addProd(x.copy(actstep).advance())
            # productions that can derivate the next symbol
            ps = stepr.prods
            while ps == stepr.prods :
                ps = stepr.prods
                for x in stepr.prods :
                    if x.aftdot[0].isupper() :
                        for y in self.step0.prods :
                            if x.aftdot[0] == y.start:
                                stepr.addProd(y.copy(actstep))
                # checking if a sub-word was produced
                for x in stepr.prods :
                    if x.aftdot == [] :
                        for y in steps[x.num] :
                            if y.aftdot[0] == x.start :
                                stepr.addProd(y.advance())
            steps.append()
        # stop conditions
        if len(actword.aftdot) == 0 :
            for x in steps[-1].prods :
                if len(x.aftdot) == 0 and x.befdot[-1] == actword.befdot[-1]:
                    return True

        return False

    






#   Def of functions:







#   expected exec example:
'''
    Linguagem: 

        S -> aTb | bTa
        R -> XRX | S
        T -> XTX | X | £
        X -> a | b

    Execucao:

    Digite a variavel inicial:
        S
    Digite, separado por '|', as regras de S: (ex: AcB|BB|a|£)
        aTb|bTa
    Digite a proxima variavel: (deixe vazio para concluir)
        R
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XRX|S
    Digite a proxima variavel: (deixe vazio para concluir)
        T
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XTX|X|£
    Digite a proxima variavel: (deixe vazio para concluir)
        X
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        a|b
    Digite a proxima variavel: (deixe vazio para concluir)

    Ok, agora digite uma palavra a ser buscada:
        aabb
    A palavra foi encontrada! O caminho foi:
    .aabb
    S -> aTb
    a.abb
    T -> XTX (aXTXb)
    X -> a (aaTXb)
    aa.bb
    T -> £ (aaXb)
    X -> b (aabb)
    aab.b
    S -> aTb (aabb)
    aabb.

'''
'''
def createrule(V: str, rules: str):
    return {V: rules.split('|')}

def showrule(R: str, rule: list):
    text = R + " -> "
    for a in rule[R]:
        text += str(a) + ' | '
    return text[:-3]



# functions tests

p = createrule("S", "aTb|bTa")
dic = dict(createrule("S", "aBc|bCb|£"))
dic.update(createrule("R", "XRX|S"))
print(dic)
s = showrule("S", dic)
print(s)
print(showrule("R", dic))
'''
g = grammar()
g.addRule("S", "aRc|Ab|£")
g.addRule("A", "a|ARb")
g.addRule("R", "Rc|a")
g.init()
print(g.validate(word("aac")))
     
