
#testing OOP usage:

class word:

    befdot: list
    aftdot: list

    def __init__(self, word: str):
        self.befdot = []
        self.aftdot = [x for x in word]
        for x in self.aftdot:
            if not (x.islower()):
                print("palavra invalida")
                return []

class production:

    num: int
    start: str
    befdot: list
    aftdot: list

    def __init__(self, num, start, befdot, aftdot) -> None:
        self.num = num
        self.start = start
        self.befdot = befdot
        self.aftdot = aftdot
    
    def advance(self) -> bool:
        if self.aftdot:
            self.befdot.append(self.aftdot.pop(0))
        else:
            return False
        return True

    def copy(self, num):
        p = production(num, self.start, self.befdot, self.aftdot)
        return p


class step:

    num: int
    prods: list
    word: word

    def __init__(self, num: int, word: word) -> None:
        self.prods = []
        self.num = num
        self.word = word

    def addProd(self, prod: production) -> bool:
        for pro in self.prods:
            if prod.num == pro.num and prod.start == pro.start and prod.aftdot == pro.aftdot and prod.befdot == pro.befdot:
                print("Esta regra ja existe")
                return False
        self.prods.append(prod)
        return True


class grammar:

    Vars: list
    Term: list
    Prod: dict
    Star: str

    def __init__(self) -> None:
        self.Vars = []
        self.Term = []
        self.Prod = {}
        self.Star = ""
    
    def addRule(self, V: str, O: str) -> None:
        if V in self.Vars:
            self.Prod[V] += O.split('|')
        else:
            self.Prod.update({V: O.split('|')})
            self.Vars.append(V)

        for x in O:
            if (x == '|'):
                pass
            elif (x.islower() or x == '£') and x not in self.Term :
                self.Term.append(x)
            elif(x.isupper() and (x not in self.Vars)) :
                self.Vars.append(x)
                self.Prod.update({x: []})
        print(*self.Vars)
        print(*self.Term)

    def init(self, w: str) -> step:
        step0 = step(0, word(w))
        for p in self.Prod['S']:
            pro = production(0, "S", [], p)
            step0.addProd(pro)
        for p in step0.prods:
            if p.aftdot[0].isupper() :
                for p1 in self.Prod[p.aftdot[0]]:
                    pro = production(0, p.aftdot[0], [], p1)
                    step0.addProd(pro)

        #Must be a function -> printing productions of a step
        for p in step0.prods:
            print(p.start, "->", str(p.befdot if (len(p.befdot)) else '' ) + '.' + str(p.aftdot) + '/' + str(p.num))        
        return step0
            

    






#   Def of functions:







#   expected exec example:
'''
    Linguagem: 

        S -> aTb | bTa
        R -> XRX | S
        T -> XTX | X | £
        X -> a | b

    Execucao:

    Digite a variavel inicial:
        S
    Digite, separado por '|', as regras de S: (ex: AcB|BB|a|£)
        aTb|bTa
    Digite a proxima variavel: (deixe vazio para concluir)
        R
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XRX|S
    Digite a proxima variavel: (deixe vazio para concluir)
        T
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XTX|X|£
    Digite a proxima variavel: (deixe vazio para concluir)
        X
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        a|b
    Digite a proxima variavel: (deixe vazio para concluir)

    Ok, agora digite uma palavra a ser buscada:
        aabb
    A palavra foi encontrada! O caminho foi:
    .aabb
    S -> aTb
    a.abb
    T -> XTX (aXTXb)
    X -> a (aaTXb)
    aa.bb
    T -> £ (aaXb)
    X -> b (aabb)
    aab.b
    S -> aTb (aabb)
    aabb.

'''

def createrule(V: str, rules: str):
    return {V: rules.split('|')}

def showrule(R: str, rule: list):
    text = R + " -> "
    for a in rule[R]:
        text += str(a) + ' | '
    return text[:-3]



# functions tests

p = createrule("S", "aTb|bTa")
dic = dict(createrule("S", "aBc|bCb|£"))
dic.update(createrule("R", "XRX|S"))
print(dic)
s = showrule("S", dic)
print(s)
print(showrule("R", dic))
g = grammar()
g.addRule("S", "aBc|bCb|£")
g.addRule("S", "RTb|bTa")
g.addRule("R", "XRX|S")
step0 = g.init("aabb")
     
