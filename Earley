
#testing OOP usage:

class grammar:

    Vars: list
    Term: list
    Prod: dict
    Star: str

    def __init__(self) -> None:
        self.Vars = []
        self.Term = []
        self.Prod = {}
        self.Star = ""
    
    def addRule(self, V: str, O: str) -> None:
        if V in self.Vars:
            self.Prod[V] += O.split('|')
        else:
            self.Prod.update({V: O.split('|')})
            self.Vars.insert(V)
        for x in O:
            if (islower(x) or x == '£') and x not in self.Term :
                self.Term += x
            
    
class production:

    num: int
    start: str
    befdot: list
    aftdot: list

    def __init__(self, num, start, befdot, aftdot) -> None:
        self.num = num
        self.start = start
        self.befdot = befdot
        self.aftdot = aftdot
    
    def advance(self) -> bool:
        if self.aftdot:
            self.befdot.append(self.aftdot.pop(0))
        else:
            return False
        return True

    def copy(self, num):
        p = production(num, self.start, self.befdot, self.aftdot)
        return p

class word:

    befdot: list
    aftdot: list

    def __init__(self, word: str):
        self.befdot = []
        self.aftdot = [x for x in word]
        for x in self.aftdot:
            if not (islower(x) or x == '£') :
                return []
        return self


class step:

    num: int
    prods: list
    word: word

    def addProd(self, prod: production) -> bool:
        if prod in self.prods:
            return False
        self.prods.insert(prod)
        return True





#   expected exec example:
'''
    Linguagem: 

        S -> aTb | bTa
        R -> XRX | S
        T -> XTX | X | £
        X -> a | b

    Execucao:

    Digite a variavel inicial:
        S
    Digite, separado por '|', as regras de S: (ex: AcB|BB|a|£)
        aTb|bTa
    Digite a proxima variavel: (deixe vazio para concluir)
        R
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XRX|S
    Digite a proxima variavel: (deixe vazio para concluir)
        T
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        XTX|X|£
    Digite a proxima variavel: (deixe vazio para concluir)
        X
    Digite, separado por '|', as regras de R: (ex: AcB|BB|a|£)
        a|b
    Digite a proxima variavel: (deixe vazio para concluir)

    Ok, agora digite uma palavra a ser buscada:
        aabb
    A palavra foi encontrada! O caminho foi:
    .aabb
    S -> aTb
    a.abb
    T -> XTX (aXTXb)
    X -> a (aaTXb)
    aa.bb
    T -> £ (aaXb)
    X -> b (aabb)
    aab.b
    S -> aTb (aabb)
    aabb.

'''

def createrule(V: str, rules: str):
    return {V: rules.split('|')}

def showrule(R: str, rule: list):
    text = R + " -> "
    for a in rule[R]:
        text += str(a) + ' | '
    return text[:-3]



# functions tests

p = createrule("S", "aTb|bTa")
dic = dict(createrule("S", "aBc|bCb|£"))
dic.update(createrule("R", "XRX|S"))
print(dic)
s = showrule("S", dic)
print(s)
print(showrule("R", dic))

     
